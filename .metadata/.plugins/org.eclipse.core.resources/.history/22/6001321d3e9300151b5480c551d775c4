package IR_Report3;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;

import org.jsoup.Jsoup; //import Jsoup
import org.jsoup.nodes.Document; //import Jsoup
import org.jsoup.nodes.Element;

public class WordStorage {

	private final static String ADDRESS = "http://cdmanii.com/";
	
	HashSet<String> hashSetString = new HashSet<>();
	HashMap<String, Integer> hashMap = new HashMap<>();
	int count = 0;
	
	public static void main(String[] args) {
		new WordStorage();
	}

	public HashSet<String> getHashSetString() {
		return hashSetString;
	}

	public HashMap<String, Integer> getHashMap() {
		return hashMap;
	}

	public int getCount() {
		return count;
	}
	
	private void CheckDF(String text) {
		System.out.println(text + " / " + count + " = " + (double)(hashMap.get(text)/count)*100 + "%");
	}

	/**
	 * 해시 테이블에 저장을 하기 위해 여러 메서드를 사용합니다.
	 */
	public WordStorage() {
		// TODO Auto-generated constructor stub

		addHash(getText(randomAddress()));

		for (String string : hashSetString) {
			System.out.println(string + "  " + hashMap.get(string));
			count += hashMap.get(string);
		}
		count = count - hashMap.get("");
		
		Scanner sc = new Scanner(System.in);
		String test = sc.nextLine();
		CheckDF(test);
	}

	/**
	 * 받아온 url에서 글을 가져옵니다.
	 * @param addressURL
	 * @return
	 */
	private String getText(String addressURL) {
		String text = null;
		try {
			Document doc = Jsoup.connect(addressURL).get(); // 웹에서
			Element contents = doc.select("*").first(); // 내용 중에서 원하는 부분을 가져온다.
			text = contents.text(); // 원하는 부분은 Elements형태로 되어 있으므로 이를
			return text;

		} catch (IOException ie) {
			System.out.println("없는 주소입니다! ErrorCode = 404");
			System.exit(0);
			return null;
		}
	}

	/**
	 * 문자열을 공백을 기준으로 구분합니다.
	 * @param text
	 * @return
	 */
	private String[] split(String text) {
		return text.split(" ");
	}

	/**
	 * 랜덤으로 url을 하나 생성합니다. (같은 블로그의 글)
	 * @return
	 */
	private String randomAddress() {
		String url = ADDRESS + randomNumber();
		System.out.println(url);
		return url;
	}

	/**
	 * 1~5000까지의 랜덤 숫자를 생성합니다.
	 * @return
	 */
	private int randomNumber() {

		return (int) (Math.random() * 5000) + 1;
	}

	/**
	 * 해시와 해시맵에 값을 저장합니다.
	 * 해시에는 단어가, 해시맵에는 단어와 그 단어의 빈도수가 들어갑니다.
	 * @param text
	 */
	private void addHash(String text) {
		String[] splitText = split(text);
		for (String string : splitText) {
			if (string.equals("")) {
				break;
			}
			string = steaming(string);

			if (hashSetString.contains(string)) {
				hashMap.put(string, hashMap.get(string) + 1);
				continue;
			} else {
				hashSetString.add(string);
				hashMap.put(string, 1);
			}
		}
	}

	/**
	 * 특수문자 제거, 스테밍을 모두 처리하는 메서드
	 * @param text
	 * @return
	 */
	private String steaming(String text) {
		text = stringReplace(text);
		if(text.equals("")) {
			return text;
		}
		text = deleteVerbe(text);
		if(text.equals("")) {
			return text;
		}
		text = replaceDump(text);
		if(text.equals("")) {
			return text;
		}
		if(text.length()==1) {
			text = "";
		}
		text.trim();
		return text;
	}

	/**
	 * 특수문자 제거 메서드
	 * @param text
	 * @return
	 */
	private String stringReplace(String text) {
		String match = "[^\uAC00-\uD7A3xfea-zA-Z\\s]";
		text = text.replaceAll(match, "");
		return text;
	}

	/**
	 * 동사일 경우 그 단어를 삭제합니다.
	 * @param text
	 * @return
	 */
	private String deleteVerbe(String text) {
		String[] match = { "요", "다", "까", "냐", "나", "어", "죠","서","자"};
		String suffixText = text.substring(text.length() - 1, text.length());
		for (int i = 0; i < match.length; i++) {
			if (suffixText.equals(match[i])) {
				text = "";
			}
		}
		return text;
	}
	
	/**
	 * 불용어일 경우 불용어를 제거한다.
	 * @param text
	 * @return
	 */
	private String replaceDump(String text) {
		String[] match = {"을","를","있","는","은","면","가","한","에","러","로","의","이"};
		String suffixText = text.substring(text.length() - 1, text.length());
		for(int i=0;i<match.length;i++) {
			if(suffixText.equals(match[i])) {
				text = text.substring(0,text.length()-1);
				break;
			}
		}
		return text;
	}

}
